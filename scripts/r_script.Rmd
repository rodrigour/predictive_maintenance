---
title: "R Notebook"
output: html_notebook
---


```{r}
library(plyr)
```


```{r}
train_df <- read.csv("C:/Users/rodrigo.coronado/OneDrive - Avanade/ML models/Git_projects/Predictive_maintenance/data/train_readings.csv")
test_df <- read.csv("C:/Users/rodrigo.coronado/OneDrive - Avanade/ML models/Git_projects/Predictive_maintenance/data/test_readings.csv")
test_labels <- read.csv("C:/Users/rodrigo.coronado/OneDrive - Avanade/ML models/Git_projects/Predictive_maintenance/data/test_labels.csv")
```

```{r}
w1 <- 30
w0 <- 15

# get the maximum cycle number for each id
d1 <- ddply(train_df,~id,summarise,max=max(cycle))
d2 <- merge(train_df,d1,by=c("id"))
```

```{r}
# generate the column RUL based on the values of columns "max" and "cycle"
d2$RUL <- d2$max - d2$cycle

d2
# exclude column "max" from the data frame
d2 <- d2[,-which(names(d2) == "max")]

# genearte label1 and label2
dataset <- d2
dataset$label1 <- ifelse(d2$RUL <= w1, 1, 0)
dataset$label2 <- ifelse(d2$RUL <= w0, 2, ifelse(d2$RUL <= w1,1,0))
```

```{r}
# This module performs feature engineering to add more features in the training data. Three additional features
# are created for each of the 21 sensors
# Generated features:
# a1-a21 - moving avearge of the corresonding sensor measure within the predefined window size w
# sd1-sd21 - moving standard deviation  of the corresonding sensor measure within the predefined window size w
# 


# set the required R library
library(zoo)

######################################################
# User input variables
# window size (window_size>=2),  most recent sensor values
window_size = 5 

######################################################
# feature engineering

# find the column index for the last 3 columns: RUL, label1, label2
col_index1 = ncol(dataset)
col_index2 = col_index1 - 1
col_index3 = col_index1 - 2

# exclude comuns id, cycle, setting1,setting2,setting3, and last 3 columns
# only the 21 sensor columns are kept in the data frame
n_pre_sensor_columns = 5 # id, cycle, setting1,setting2,setting3
n_after_sensor_columns = 3 #RUL, label1, label2
n_col = ncol(dataset)

data=dataset[,-c(1:n_pre_sensor_columns,col_index3,col_index2,col_index1)]
n_sensor=ncol(data) # 21 sensors

id=unique(dataset[,1])
n_id=length(id) # 100

# generate column names

a = paste("a",(1:n_sensor),sep="") # average
sd =paste("sd",(1:n_sensor),sep="") # standard deviation



# get rolling mean and rolling sd
rollingmean = c()
rollingsd = c()

# loop for each unique engine id
for(i in 1:length(id)){
  
    # get the subset of the data that only contains the sensor columns for the id i
    sub_data = subset(dataset[,(n_pre_sensor_columns+1):(n_col-n_after_sensor_columns)],dataset$id==id[i])
    
    # window size is adjusted if the it is greater than the number of rows in the data
    n_row_subdata = nrow(sub_data)
    w=ifelse(window_size < n_row_subdata,window_size,n_row_subdata)
    
    # get the rolling mean for all sensors
    rollingmean = rbind(rollingmean,rollapply(sub_data,w,mean,align = "right",partial=1))
    
    # get the rolling sd for all sensors
    rollingsd_i = rollapply(sub_data,w,sd,align = "right",partial=1)
    rollingsd_i[is.na(rollingsd_i)]=0
    rollingsd = rbind(rollingsd,rollingsd_i)

    

}
data_a = as.data.frame(rollingmean)
data_sd = as.data.frame(rollingsd)

names(data_a) = a
names(data_sd) = sd



df = cbind(data_a,data_sd)

df2=cbind(dataset[,1:(n_pre_sensor_columns+n_sensor)],df)
df2$RUL=dataset$RUL
df2$label1=dataset$label1
df2$label2=dataset$label2


# generate output data
data.set = df2
# Select data.frame to be sent to the output Dataset port
maml.mapOutputPort("data.set");
```

